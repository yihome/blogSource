---
title: Java线程同步关键字
date: 2018-07-26 11:22:43
tags: [Android,线程]
---

## 线程安全性
当一个类被多个线程访问时，不需要额外考虑额外的同步代码以及线程调度方面的考虑，如果这个类的行为仍然时正确的，这个类就是线程安全的。

### 线程安全性问题
我们知道在单线程环境下Java程序运行时不会有任何问题，但是多线程运行时就可能会出现问题，这主要是由于如下原因
* 线程执行顺序不可知
* 线程可见性

### 线程执行顺序不可知
这个情况最好理解，由于cpu对于线程的调度不可预知，我们无法根据线程的开始时间来判断线程的运行情况，这就比如有两个线程A,B他们的执行顺序分别是`A1>>A2>>A3`和`B1>>B2>>B3`，我们无法预测最终的执行顺序是`A1>>B1>>A2>>B2>>A3>>B3`还是`A1>>A2>>A3>>B1>>B2>>B3`。

### 线程可见性
在Java内存模型中，线程间共享的变量都存储在主内存中，但是每个线程都会拥有一个私有的本地内存，这个和CPU的高速缓存是一个概念，每次线程修改一个共享变量时，都是先写入到本地内存中，然后在同步到共享内存中，


## synchronized
当对象不是无状态同时也没有方法提供原子的操作方法时，就需要额外的机制来保障线程安全性。而synchronized块，对象的内置锁机制就是其中一个用于保障线程安全性机制。


synchronized块包含两块部分，锁对象和锁保护的代码块，而synchronized方法就是将这个代码块的范围扩大到了整个方法体，静态的synchronized方法则是从class对象上获取锁。

内置锁的几个特点如下

* 互斥 同时只能有一个线程获取锁，当锁被占有，其他线程只能等待或者阻塞
* 重进入 当一个线程试图获得它已经占有的锁，这样的请求是会成功的，且锁计数+1

## 总结
内置锁是从对象上获取的，synchronized只是使用这个对象锁，当线程进入synchronized代码块前自动获得锁且锁计数+1，退出时锁计数-1，直到计数为0时自动放弃锁。
